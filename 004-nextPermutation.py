import time
# # ################################# 下一个排列 ##################################
# num1 = [1,2,3]     # 1,3,2
# num1 = [1,3,2]     # 2,1,3
# num1 = [2,1,3]     # 2,3,1
# num1 = [2,3,1]     # 3,1,2
# num1 = [3,1,2]    # 3,2,1
# num1 = [3,2,1]     # 1,2,3
# #
# num1 = [1,1,5]     # 1,5,1
# num1 = [5,4,7,5,3,2]     # [5,5,2,3,4,7]
# num1 = [5,1,7,6,5,4]     # [5,4,1,5,6,7]
# num1 = [5,2,7,5,3,2]     # [5,3,2,2,5,7]
# num1 = [2,7,3]     # 3,2,7
# num1 = [4,2,0,2,3,2,0]      # [4,2,0,3,0,2,2]
#
#
# class Solution(object):
#     def nextPermutation(self, nums):
#         """
#         :type nums: List[int]
#         :rtype: None Do not return anything, modify nums in-place instead.
#         """
#         def reverse(nums, i, j):
#             while i < j:
#                 nums[i], nums[j] = nums[j], nums[i]
#                 i += 1
#                 j -= 1
#
#         length = len(nums)
#         i = length-1
#         while i > 0:
#             if nums[i] <= nums[i-1]:
#                 i -= 1
#             else:
#                 tmp = nums[i-1]
#                 if i == length-1:
#                     nums[i-1] = nums[i]
#                     nums[i] = tmp
#                 else:
#                     if nums[i-1] >= nums[i+1]:
#                         nums[i-1] = nums[i]
#                         nums[i] = tmp
#                         # nums[i:] = nums[i:][::-1]
#                         reverse(nums, i, length - 1)
#                     else:
#                         # 应该是把比i-1大一点的数和i-1交换位置,然后将剩下的反转
#                         flag = 1
#                         for j in range(i+2,length):
#                             if nums[j] <= tmp:
#                                 flag = 0
#                                 break
#                         if flag:
#                             j = length
#                         nums[i-1] = nums[j-1]
#                         nums[j-1] = tmp
#
#                         # nums[i:] = nums[i:][::-1]
#                         reverse(nums, i, length - 1)
#                 break
#
#         if i == 0:
#             reverse(nums, 0, length-1)
#             # nums[:] = nums[::-1]
#
#
# print(num1)
# solve = Solution()
# solve.nextPermutation(num1)
# print(num1)

# # ################################# 最长有效括号 ##################################
# num = "(()"     # 2
# num = ")()())"     # 4
# num = "(()())"     # 6
# num = "(()(()))"     # 8
# num = "(()()))"     # 6
# num = "()(()"       # 2
# num = ""
# num = "()(()()"       # 4
# # num = ")("
# num = ")()())()()("     # 4
#
#
# class Solution(object):
#     def longestValidParentheses(self, s):
#         """
#         :type s: str
#         :rtype: int
#         """
#         # # 我的算法是把字符中不符合的括号的index找出来,这样所有满足要求的字符都在这些索引之间
#         # res = 0
#         # l_inds = []
#         # r_inds = []
#         # for ind, ss in enumerate(s):
#         #     if ss == "(":
#         #         l_inds.append(ind)
#         #     else:
#         #         if l_inds:
#         #             l_inds.pop(-1)
#         #             res += 2
#         #
#         #         else:
#         #             r_inds.append(ind)
#         #             continue
#         # l_inds.extend(r_inds)
#         # l_inds.sort()
#         #
#         # if l_inds:
#         #     # inds2 = l_inds.copy()
#         #     inds2 = l_inds[:]
#         #     inds2.append(len(s))
#         #     l_inds.insert(0, -1)
#         #     # print(l_inds)
#         #     # print(inds2)
#         #     for i in range(len(l_inds)):
#         #         l_inds[i] = inds2[i] - l_inds[i] - 1
#         #     ans = max(l_inds)
#         # else:
#         #     ans = len(s)
#         #
#         # return ans
#
#
#         # res = 0
#         # stack = [-1]
#         # for i, v in enumerate(s):
#         #     if v == '(':
#         #         stack.append(i)
#         #     else:
#         #         stack.pop()
#         #         if not stack:
#         #             stack.append(i)
#         #         else:
#         #             res = max(res, i - stack[-1])
#         # return res
#
#
#         # 动态规划
#         if not s:
#             return 0
#
#         n = len(s)
#         dp = [0]*n
#         for i in range(1, n):
#             # 要与前一个元素多匹配，所以从索引1开始遍历
#             if s[i] == ')':
#                 # 当前右括号与前一个符号匹配，若匹配符号之前还有匹配字符，需要额外增加数值
#                 if i-1 >= 0 and s[i-1] == '(':
#                     dp[i] = 2 + (dp[i-2] if i-2 >= 0 else 0)
#                 elif i-1-dp[i-1] >= 0 and s[i-1-dp[i-1]] == '(':
#                     dp[i] = 2+dp[i-1] + (dp[i-2-dp[i-1]] if i-2-dp[i-1] >= 0 else 0)
#         return max(dp)
#
#
# solve = Solution()
# print(solve.longestValidParentheses(num))

# # ################################# 搜索旋转排序数组 ##################################
# # 要求 O(log n)
# nums1 = [4,5,6,7,0,1,2]      # 4
# target1 = 0
#
# # nums1 = [4,5,6,7,0,1,2]      # -1
# # target1 = 3
#
# # nums1 = [1,3]      # -1
# # target1 = 1
#
# # nums1 = [1,3,5]      # 1
# # target1 = 3
#
#
# # 1. 一分为二.必定一有序一无序
# class Solution(object):
#     def half_search(self, nums, target):
#         if not nums:
#             return -1
#
#         i = (len(nums)-1)//2
#         if nums[i] > target:
#             tmp = self.half_search(nums[:i], target)
#             if tmp == -1:
#                 return -1
#             else:
#                 return tmp
#         elif nums[i] < target:
#             tmp = self.half_search(nums[(i+1):], target)
#             if tmp == -1:
#                 return -1
#             else:
#                 return i + 1 + tmp
#         else:
#             return i
#
#     def search(self, nums, target):
#         """
#         :type nums: List[int]
#         :type target: int
#         :rtype: int
#         """
#         if not nums:
#             return -1
#         if len(nums) == 1:
#             if nums[0] == target:
#                 return 0
#             else:
#                 return -1
#
#         i = (len(nums)-1) // 2
#         if nums[0] < nums[i]:
#             tmp = self.half_search(nums[:i+1], target)
#             if tmp == -1:
#                 ttmp = self.search(nums[i+1:], target)
#                 if ttmp == -1:
#                     return -1
#                 else:
#                     return i + 1 + ttmp
#             else:
#                 return tmp
#         else:
#             tmp = self.half_search(nums[i+1:], target)
#             if tmp == -1:
#                 return self.search(nums[:i+1], target)
#             else:
#                 return i + 1 + tmp
#
#
# # 2. 先二分和它的右端点比较来找旋转的地方,再二分找目标
# class Solution(object):
#     def search(self, nums, target):
#         """
#         :type nums: List[int]
#         :type target: int
#         :rtype: int
#         """
#         if not nums: return -1
#         n = len(nums)
#         left = 0
#         right = len(nums) - 1
#         while left < right:
#             mid = left + (right - left) // 2
#             if nums[mid] > nums[right]:
#                 left = mid + 1
#             else:
#                 right = mid
#         t = left
#         left = 0
#         right = len(nums) - 1
#         while left <= right:
#             mid = (left + right) // 2
#             realmid = (mid + t) % n
#             if nums[realmid] == target:
#                 return realmid
#             elif nums[realmid] > target:
#                 right = mid - 1
#             else:
#                 left = mid + 1
#         return -1
#
#
# solve = Solution()
# print(solve.search(nums1, target1))

# # ################################# 搜索旋转排序数组 ##################################
# # O(log n)
# nums1 = [5,7,7,8,8,10]      # [3,4]
# target1 = 8
#
# # nums1 = [5,7,7,8,8,10]      # [-1,-1]
# # target1 = 6
#
# # nums1 = [0,0,0,1,2,4,5,6,7]      # 4
# # target1 = 0
#
# # nums1 = [0,1,2,4,5,6,7]      # -1
# # target1 = 3
#
# # nums1 = [1,1,1]      # -1
# # target1 = 1
# #
# # nums1 = [1,3,3,5]      # 1
# # target1 = 3
#
#
# # 先折半查找找到,再从该ind出发找range
# # 有问题 如果数组全是目标值就变成 O(n)了
# # class Solution(object):
# #     def half_search(self, nums, target):
# #         if not nums:
# #             return -1
# #
# #         i = (len(nums)-1)//2
# #         if nums[i] > target:
# #             tmp = self.half_search(nums[:i], target)
# #             if tmp == -1:
# #                 return -1
# #             else:
# #                 return tmp
# #         elif nums[i] < target:
# #             tmp = self.half_search(nums[(i+1):], target)
# #             if tmp == -1:
# #                 return -1
# #             else:
# #                 return i + 1 + tmp
# #         else:
# #             return i
# #
# #     def searchRange(self, nums, target):
# #         """
# #         :type nums: List[int]
# #         :type target: int
# #         :rtype: List[int]
# #         """
# #         if not nums:
# #             return [-1, -1]
# #
# #         ind = self.half_search(nums, target)
# #         if ind == -1:
# #             return [-1, -1]
# #         else:
# #             res = [ind, ind]
# #             while res[0]-1 >= 0 and nums[res[0]-1] == target:
# #                 res[0] -= 1
# #             while res[1]+1 < len(nums) and nums[res[1]+1] == target:
# #                 res[1] += 1
# #
# #         return res
#
#
# # 双指针用二分查找分别缩小找区间的两个边界
# class Solution(object):
#     def searchRange(self, nums, target):
#         """
#         :type nums: List[int]
#         :type target: int
#         :rtype: List[int]
#         """
#         if nums == []:
#             return [-1,-1]
#         i = 0
#         j = len(nums)
#         while i < j:
#             mid = (i+j) // 2
#             if nums[mid] >= target:
#                 j = mid
#             else:
#             # elif nums[mid] < target:
#                 i = mid + 1
#         left = i
#         i = 0
#         j = len(nums)
#         while i < j:
#             mid = (i+j) // 2
#             if nums[mid] == target:
#                 i = mid + 1
#             elif nums[mid] < target:
#                 i = mid + 1
#             elif nums[mid] > target:
#                 j = mid
#         right = i - 1
#         if left == len(nums) or nums[left] != target:
#             return [-1, -1]
#         else:
#             return [left, right]
#
#
# solve = Solution()
# print(solve.searchRange(nums1, target1))

# # ################################# 搜索插入位置 ##################################
# nums1 = [5,7,8,10]      # 2
# target1 = 8
#
# nums1 = [7,8]      # 2
# target1 = 8
#
# # nums1 = [1,3,5,6]       # 2
# # target1 = 5
#
# # nums1 = [1,3,5,6]       # 1
# # target1 = 2
#
# # nums1 = [1,3,5,6]       # 0
# # target1 = 0
#
# # nums1 = [1,3,5,6]       # 4
# # target1 = 7
#
# nums1 = []       # 4
# target1 = 7
#
#
# # mid = (left + right) >> 1 通过右移替代除以2效率更高. >>> C++中是无符号右移的意思
# class Solution(object):
#     def searchInsert(self, nums, target):
#         """
#         :type nums: List[int]
#         :type target: int
#         :rtype: int
#         """
#         if not nums:
#             return 0
#
#         i = (len(nums)-1)//2
#         if nums[i] > target:
#             # tmp = self.searchInsert(nums[:i], target)
#             return self.searchInsert(nums[:i], target)
#         elif nums[i] < target:
#             # tmp = self.searchInsert(nums[(i + 1):], target)
#             return i + 1 + self.searchInsert(nums[(i + 1):], target)
#         else:
#             return i
#
#
#         # # 别人的二分
#         # left = 0
#         # right = len(nums) - 1
#         # while left <= right:
#         #     mid = left + (right - left) // 2    # 这么写是为了避免 r+l 溢出
#         #     if nums[mid] == target:
#         #         return mid
#         #     elif nums[mid] < target:
#         #         left = mid + 1
#         #     else:
#         #         right = mid - 1
#         # return left
#
#
# solve = Solution()
# print(solve.searchInsert(nums1, target1))

# # ################################# 有效的数独 ##################################
# num = \
# [
#   ["5","3",".",".","7",".",".",".","."],
#   ["6",".",".","1","9","5",".",".","."],
#   [".","9","8",".",".",".",".","6","."],
#   ["8",".",".",".","6",".",".",".","3"],
#   ["4",".",".","8",".","3",".",".","1"],
#   ["7",".",".",".","2",".",".",".","6"],
#   [".","6",".",".",".",".","2","8","."],
#   [".",".",".","4","1","9",".",".","5"],
#   [".",".",".",".","8",".",".","7","9"]
# ]       # True
#
# # num = \
# # [ ["8","3",".",".","7",".",".",".","."],
# #   ["6",".",".","1","9","5",".",".","."],
# #   [".","9","8",".",".",".",".","6","."],
# #   ["8",".",".",".","6",".",".",".","3"],
# #   ["4",".",".","8",".","3",".",".","1"],
# #   ["7",".",".",".","2",".",".",".","6"],
# #   [".","6",".",".",".",".","2","8","."],
# #   [".",".",".","4","1","9",".",".","5"],
# #   [".",".",".",".","8",".",".","7","9"]] # False
#
# # num = \
# # [
# #   ["5","3",".",".","7",".",".",".","."],
# #   ["6",".",".","1","9","5",".",".","."],
# #   [".","9","8",".",".",".",".","6","."],
# #   ["8",".",".",".","6",".",".",".","3"],
# #   ["4",".",".","8",".","3",".",".","1"],
# #   ["7",".",".",".","2",".",".",".","6"],
# #   [".","6",".",".",".",".","2","8","."],
# #   [".",".",".","4","1","9",".",".","5"],
# #   [".",".",".",".","8",".",".","7","9"]
# # ] # False
# #
# # num = \
# # [
# #   ["5","3",".",".","7",".",".",".","."],
# #   ["6",".",".","1","9","5",".",".","."],
# #   [".","9","8",".",".",".",".","6","."],
# #   ["8",".",".",".","6",".",".",".","3"],
# #   ["4",".",".","8",".","3",".",".","1"],
# #   ["7",".",".",".","2",".",".",".","6"],
# #   [".","6",".",".",".",".","2","8","."],
# #   [".",".",".","4","2","9",".",".","5"],
# #   [".",".",".",".","8",".",".","7","9"]
# # ] # False
#
# num = [[".","2",".",".",".",".",".",".","."],
#        [".",".",".",".",".",".","5",".","1"],
#        [".",".",".",".",".",".","8","1","3"],
#        ["4",".","9",".",".",".",".",".","."],
#        [".",".",".",".",".",".",".",".","."],
#        [".",".","2",".",".",".",".",".","."],
#        ["7",".","6",".",".",".",".",".","."],
#        ["9",".",".",".",".","4",".",".","."],
#        [".",".",".",".",".",".",".",".","."]]
#
#
# class Solution(object):
#     def nineValid(self, list_nums):
#         lis = list(range(1, 10))
#         for s in list_nums:
#             if s != ".":
#                 try:
#                     lis.remove(int(s))
#                 except:
#                     return False
#         return True
#
#     def isValidSudoku(self, board):
#         """
#         :type board: List[List[str]]
#         :rtype: bool
#         """
#         tmp_block1 = []
#         tmp_block2 = []
#         tmp_block3 = []
#         for j in range(9):
#             tmp_ver = []
#             if j % 3 == 0:
#                 flag = self.nineValid(tmp_block1) and self.nineValid(tmp_block2) and self.nineValid(tmp_block3)
#                 if not flag:
#                     return False
#                 tmp_block1 = []
#                 tmp_block2 = []
#                 tmp_block3 = []
#             for i in range(9):
#                 if j == 0:
#                     if not self.nineValid(board[i]):
#                         return False
#                 tmp_ver.append(board[i][j])
#
#                 if i <= 2:
#                     tmp_block1.append(board[i][j])
#                 elif i <= 5:
#                     tmp_block2.append(board[i][j])
#                 else:
#                     tmp_block3.append(board[i][j])
#
#             if not self.nineValid(tmp_ver):
#                 return False
#
#         flag = self.nineValid(tmp_block1) and self.nineValid(tmp_block2) and self.nineValid(tmp_block3)
#         if not flag:
#             return False
#         return True
#
#
# class Solution(object):
#     def isValidSudoku(self, board):
#         from collections import defaultdict
#         row = defaultdict(set)
#         col = defaultdict(set)
#         small_square = defaultdict(set)
#
#         for i in range(9):
#             for j in range(9):
#                 if board[i][j].isdigit():
#                     if board[i][j] not in row[i] \
#                             and board[i][j] not in col[j] \
#                             and board[i][j] not in small_square[(i // 3, j // 3)]:
#                         row[i].add(board[i][j])
#                         col[j].add(board[i][j])
#                         small_square[(i // 3, j // 3)].add(board[i][j])
#                     else:
#                         return False
#         return True
#
#
#         dic={}
#         for i in range(len(board)):
#             for j in range(len(board[0])):
#                 if board[i][j] in dic and not board[i][j]=='.':
#                     for item in dic[board[i][j]]:
#                         if item[0]==i or item[1]==j or (item[0]//3==i//3 and item[1]//3==j//3):
#                             return False
#                 dic.setdefault(board[i][j],[]).append([i,j])
#         return True
#
#
# solve = Solution()
# print(solve.isValidSudoku(num))

# # ################################# 解数独 ##################################
# # num = \
# # [
# #   ["0","0","0","3","3","3","6","6","6"],
# #   ["0","0","0","3","3","3","6","6","6"],
# #   ["0","0","0","3","3","3","6","6","6"],
# #   ["1","1","1","4","4","4","7","7","7"],
# #   ["1","1","1","4","4","4","7","7","7"],
# #   ["1","1","1","4","4","4","7","7","7"],
# #   ["2","2","2","5","5","5","8","8","8"],
# #   ["2","2","2","5","5","5","8","8","8"],
# #   ["2","2","2","5","5","5","8","8","8"]
# # ]
# num = \
# [
#   ["5","3",".",".","7",".",".",".","."],
#   ["6",".",".","1","9","5",".",".","."],
#   [".","9","8",".",".",".",".","6","."],
#   ["8",".",".",".","6",".",".",".","3"],
#   ["4",".",".","8",".","3",".",".","1"],
#   ["7",".",".",".","2",".",".",".","6"],
#   [".","6",".",".",".",".","2","8","."],
#   [".",".",".","4","1","9",".",".","5"],
#   [".",".",".",".","8",".",".","7","9"]
# ]       # True
#
# num = [[".",".","9","7","4","8",".",".","."],
#        ["7",".",".",".",".",".",".",".","."],
#        [".","2",".","1",".","9",".",".","."],
#        [".",".","7",".",".",".","2","4","."],
#        [".","6","4",".","1",".","5","9","."],
#        [".","9","8",".",".",".","3",".","."],
#        [".",".",".","8",".","3",".","2","."],
#        [".",".",".",".",".",".",".",".","6"],
#        [".",".",".","2","7","5","9",".","."]]
#
#
# # 第一种想法基于一个未能证明,可能不对的假设:
# # 只有唯一解,说明至少有一个格子的候选中只有一个元素
# # 好的 这一假设不成立...................
# # 需要用回溯...............
# # class Solution(object):
# #     def preprocess(self, board):
# #         key = "123456789"
# #         tmp_block1 = []
# #         tmp_block2 = []
# #         tmp_block3 = []
# #         lis_block = []
# #         lis_ver = []
# #         lis_hor = []
# #         cnt = 0
# #         for j in range(9):
# #             tmp_ver = []
# #             tmp_hor = []
# #             if j % 3 == 0 and j != 0:
# #                 lis_block.append(tmp_block1)
# #                 lis_block.append(tmp_block2)
# #                 lis_block.append(tmp_block3)
# #                 tmp_block1 = []
# #                 tmp_block2 = []
# #                 tmp_block3 = []
# #             for i in range(9):
# #                 if board[j][i] != ".":
# #                     tmp_hor.append(board[j][i])
# #
# #                 if board[i][j] != ".":
# #                     tmp_ver.append(board[i][j])
# #
# #                     if i <= 2:
# #                         tmp_block1.append(board[i][j])
# #                     elif i <= 5:
# #                         tmp_block2.append(board[i][j])
# #                     else:
# #                         tmp_block3.append(board[i][j])
# #                 else:
# #                     board[i][j] = key
# #                     cnt += 1
# #
# #             lis_ver.append(tmp_ver)
# #             lis_hor.append(tmp_hor)
# #         lis_block.append(tmp_block1)
# #         lis_block.append(tmp_block2)
# #         lis_block.append(tmp_block3)
# #
# #         return lis_block, lis_ver, lis_hor, cnt
# #
# #     def solveSudoku(self, board):
# #         """
# #         :type board: List[List[str]]
# #         :rtype: None Do not return anything, modify board in-place instead.
# #         """
# #         lis_block, lis_ver, lis_hor, cnt = self.preprocess(board)
# #         old_cnt = 81
# #         while cnt > 0 and old_cnt - cnt > 0:
# #         # while cnt > 0:
# #             old_cnt = cnt
# #             for i in range(9):
# #                 for j in range(9):
# #                     if len(board[i][j]) > 1:
# #                         for h in board[i][j]:
# #                             if h in lis_hor[i]:
# #                                 board[i][j] = board[i][j].replace(h, '')
# #                         for v in board[i][j]:
# #                             if v in lis_ver[j]:
# #                                 board[i][j] = board[i][j].replace(v, '')
# #                         for b in board[i][j]:    # i//3 + 3*(j//3)是对应的block
# #                             if b in lis_block[(i//3+3*(j//3))]:
# #                                 board[i][j] = board[i][j].replace(b, '')
# #
# #                         if len(board[i][j]) == 1:
# #                             cnt -= 1
# #                             lis_block[(i//3+3*(j//3))].append(board[i][j])
# #                             lis_ver[j].append(board[i][j])
# #                             lis_hor[i].append(board[i][j])
# # #         print(cnt)
#
#
# # 回溯
# class Solution:
#     def solveSudoku(self, board):
#         """
#         Do not return anything, modify board in-place instead.
#         """
#         # 把所有没填数字的位置找到
#         all_points = []
#         for i in range(9):
#             for j in range(9):
#                 if board[i][j] == ".":
#                     all_points.append([i, j])
#
#         # check函数是为了检查是否在point位置k是合适的
#         def check(point, k):
#             row_i = point[0]
#             col_j = point[1]
#             for i in range(9):
#                 # 检查 行
#                 if i != row_i and board[i][col_j] == k:
#                     return False
#                 # 检查 列
#                 if i != col_j and board[row_i][i] == k:
#                     return False
#             # 检查块
#             for i in range(row_i // 3 * 3, row_i // 3 * 3 + 3):
#                 for j in range(col_j // 3 * 3, col_j // 3 * 3 + 3):
#                     if i != row_i and j != col_j and board[i][j] == k:
#                         return False
#
#             return True
#
#         def backtrack(i):
#             # 回溯终止条件
#             if i == len(all_points):
#                 return True
#             for j in range(1, 10):
#                 # 检查是否合适
#                 if check(all_points[i], str(j)):
#                     # 合适就把位置改过来
#                     board[all_points[i][0]][all_points[i][1]] = str(j)
#                     if backtrack(i + 1):  # 回溯下一个点
#                         return True
#                     board[all_points[i][0]][all_points[i][1]] = "."  # 不成功把原来改回来
#             return False
#
#         backtrack(0)
#
#
# # 优化后的回溯
# class Solution:
#     def solveSudoku(self, board):
#         row = [set(range(1, 10)) for _ in range(9)]  # 行剩余可用数字
#         col = [set(range(1, 10)) for _ in range(9)]  # 列剩余可用数字
#         block = [set(range(1, 10)) for _ in range(9)]  # 块剩余可用数字
#
#         empty = []  # 收集需填数位置
#         for i in range(9):
#             for j in range(9):
#                 if board[i][j] != '.':  # 更新可用数字
#                     val = int(board[i][j])
#                     row[i].remove(val)
#                     col[j].remove(val)
#                     block[(i // 3)*3 + j // 3].remove(val)
#                 else:
#                     empty.append((i, j))
#
#         def backtrack(iter=0):
#             if iter == len(empty):  # 处理完empty代表找到了答案
#                 return True
#             i, j = empty[iter]
#             b = (i // 3)*3 + j // 3
#             for val in row[i] & col[j] & block[b]:
#                 row[i].remove(val)
#                 col[j].remove(val)
#                 block[b].remove(val)
#                 board[i][j] = str(val)
#                 if backtrack(iter+1):
#                     return True
#                 row[i].add(val)  # 回溯
#                 col[j].add(val)
#                 block[b].add(val)
#             return False
#         backtrack()
#
#
# solve = Solution()
# solve.solveSudoku(num)
# print(num)

# # # ################################# 报数 ##################################
# # 1 ≤ n ≤ 30
# num = 1     # "1"
# num = 2     # "11"
# num = 3     # "21"
# num = 4     # "1211"
# num = 5     # "111221"
#
# dic = {
#     1: "1",
#     2: "11",
#     3: "21",
#     4: "1211",
#     5: "111221",
#     6: "312211",
#     7: "13112221",
#     8: "1113213211",
#     9: "31131211131221",
#     10: "13211311123113112211",
#     11: "11131221133112132113212221",
#     12: "3113112221232112111312211312113211",
#     13: "1321132132111213122112311311222113111221131221",
#     14: "11131221131211131231121113112221121321132132211331222113112211",
#     15: "311311222113111231131112132112311321322112111312211312111322212311322113212221",
#     16: "132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211",
#     17: "11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221",
#     18: "31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211",
#     19: "1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221",
#     20: "11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211",
#     21: "311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221",
#     22: "132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211",
#     23: "111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221",
#     24: "3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211",
#     25: "132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221",
#     26: "1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211",
#     27: "31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221",
#     28: "13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211",
#     29: "11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221",
#     30: "3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211",
# }
#
#
# class Solution(object):
#     def readBefore(self, n):
#         res = ''
#         length = len(n)
#         ind = 0
#         while ind < length:
#             cnt = 1
#             for i in n[ind + 1:]:
#                 if i == n[ind]:
#                     cnt += 1
#                 else:
#                     break
#             res = res + str(cnt) + n[ind]
#             ind += cnt
#         return res
#
#     def countAndSay(self, n):
#         """
#         :type n: int
#         :rtype: str
#         """
#         tmp = '1'
#         while n > 1:
#             tmp = self.readBefore(tmp)
#             n -= 1
#
#         return tmp
#
#
# solve = Solution()
# print(solve.countAndSay(num))
#
# flag = 1
# for i in range(1,31):
#     tmp = solve.countAndSay(i)
#     flag = flag and (tmp == dic[i])
# print(flag)

# # ################################# 组合总和 ##################################
# # candidates里正整数
# candidates1 = [2,3,6,7]     # [[7], [2,2,3]]
# target1 = 7
#
# # candidates1 = [2,3,5]     # [[2,2,2,2], [2,3,3], [3,5]]
# # target1 = 8
#
# candidates1 = [1,4,5]     # [[2,2,2,2], [2,3,3], [3,5]]
# target1 = 5
#
# # candidates1 = [3,6,7,2]     # [[7], [2,2,3]]
# # target1 = 7
#
#
# # # 受汉诺塔那个的启发,使用递归
# # # 如果先排序 就可以break减少时间损耗; 不排序就不需要break
# # class Solution(object):
# #     def addElement(self, num, lis):
# #         for l in lis:
# #             l.insert(0, num)
# #
# #         return lis
# #
# #     def combinationSum(self, candidates, target):
# #         """
# #         :type candidates: List[int]
# #         :type target: int
# #         :rtype: List[List[int]]
# #         """
# #         # candidates.sort()
# #
# #         def findTarget(candidates, target):
# #             ans = []
# #             for ind, num in enumerate(candidates):
# #                 if num < target:
# #                     tmp = findTarget(candidates[ind:], target - num)
# #                     if tmp:
# #                         ans.extend(self.addElement(num, tmp))
# #                 elif num == target:
# #                     ans.append([num])
# #                 # else:
# #                 #     break
# #             return ans
# #
# #         return findTarget(candidates, target)
#
#
# # 用回溯法:
# class Solution(object):
#     def combinationSum(self, candidates, target):
#         res = []
#
#         def backward(nums, target, index, selected):
#
#             if target < 0: return
#             if target == 0:
#                 res.append(selected)
#                 return
#             for i in range(index, len(nums)):
#                 if nums[i] > target: break
#                 backward(nums, target - nums[i], i, selected + [nums[i]])
#
#         candidates.sort()
#         backward(candidates, target, 0, [])
#         return res
#
#
# # 最快解法
# class Solution(object):
#     def combinationSum(self, candidates, target):
#         candidates.sort()
#         res = list()
#         st = list()
#         n = len(candidates)
#         i = 0
#         while True:
#             if target == 0:
#                 res.append([candidates[i] for i in st])
#                 i = st.pop()
#                 target += candidates[i]
#                 i += 1
#             elif i == n or candidates[i] > target:
#                 if len(st) == 0:
#                     return res
#                 i = st.pop()
#                 target += candidates[i]
#                 i += 1
#             elif candidates[i] <= target:
#                 st.append(i)
#                 target -= candidates[i]
#
#
# solve = Solution()
# print(solve.combinationSum(candidates1, target1))

# # ################################# 40.组合总和 II ##################################
# 不同于前一题. candidates中的每个数字在每个组合中只能使用一次。
# candidates1 = [10,1,2,7,6,1,5]       # [[1, 7], [1, 2, 5], [2, 6], [1, 1, 6]]
# target1 = 8

candidates1 = [2,5,2,1,2]       # [[1,2,2], [5]]
target1 = 5


# 做法和前一题一样...跳过重复元素就行了
class Solution(object):
    def addElement(self, num, lis):
        for l in lis:
            l.insert(0, num)

        return lis

    def combinationSum2(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        candidates.sort()

        def findTarget(candidates, target):
            ans = []
            for ind, num in enumerate(candidates):
                if ind > 0:
                    if num == candidates[ind-1]:
                        continue
                if num < target:
                    tmp = findTarget(candidates[ind+1:], target - num)
                    if tmp:
                        ans.extend(self.addElement(num, tmp))
                elif num == target:
                    ans.append([num])
                else:
                    break
            return ans

        return findTarget(candidates, target)


solve = Solution()
print(solve.combinationSum2(candidates1, target1))
